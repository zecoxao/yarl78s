##########################################################################
#
# Attempt at implementing the RL78
# 16-bit MCU ISA in SLEIGH.
# Wish me luck.
#
# Disclaimer: If this disclaimer is 
# still present when you obtain this 
# file, assume it is non-functional.
# I'm trying my best here.
#
##########################################################################

define endian=little;
define alignment=1;

@define PTRSIZE "3"

define space ram 		type=ram_space		size=$(PTRSIZE) wordsize=1	default;
define space stackarea 	type=ram_space 		size=2;
define space register 	type=register_space size=1;

#TODO: mess with a virtual stack register of some sort using context registers?
#TODO: figure out how to cleanly implement register banks
#TODO: refactor bunk register access logic, using pg. 3 of the data sheet as a reference
#TODO: figure out how to use sleigh's carry operation, pretty sure thats available.
#TODO: check literally every single operand namespace, you may have screwed up ordering

#general purpose registers:
define register offset= 0x00 size=1 [X3 A3 C3 B3 E3 D3 L3 H3]; 	# 8-bit-mode bank3
define register offset= 0x00 size=2 [AX3   BC3   DE3   HL3];	#16-bit-mode bank3
define register offset= 0x08 size=1 [X2 A2 C2 B2 E2 D2 L2 H2]; 	# 8-bit-mode bank2
define register offset= 0x08 size=2 [AX2   BC2   DE2   HL2];	#16-bit-mode bank2
define register offset= 0x10 size=1 [X1 A1 C1 B1 E1 D1 L1 H1]; 	# 8-bit-mode bank1
define register offset= 0x10 size=2 [AX1   BC1   DE1   HL1];	#16-bit-mode bank1
define register offset= 0x18 size=1 [X  A  C  B  E  D  L  H]; 	# 8-bit-mode bank0
define register offset= 0x18 size=2 [AX    BC    DE    HL];	 	#16-bit-mode bank0
#define register offset= 0x20 size=1 [RB0 RB1 RB2 RB3];			#dummy args for register banks

#special purpose registers
define register offset=0x40 size=3 [PC]; #I Think this is right??? they don't specify
define register offset=0x50 size=2 [SP      _     _     _      ];
define register offset=0x50 size=1 [SPL SPH PSW _ CS ES PMC MEM];
define register offset=0x60 size=4 [contextreg _]; # dumb hack to help the context reg dealio


define context contextreg
	banksel = (0,1)
;



#TODO: change to using bitranges, once its fixed
#define bitrange IE=PSW[7,1] Z=PSW[6,1] RBS1=PSW[5,1] AC=PSW[4,1] RBS0=PSW[3,1] 
#				ISP1=PSW[2,1] ISP0=PSW[1,1] CY=PSW[0,1];

#Flag bits
#Macros? I think? to make accessing the bits in the PSW easier
#TODO: convert elements of the PSW to use the bitrange feature
@define IE_flag 	"PSW[7,1]"	# Interrupt Enable (IE)
@define Z_flag  	"PSW[6,1]" 	# Zero Flag (Z)
@define RBS1_flag   "PSW[5,1]"	# Register Bank Select Hi-Bit (RBS1)
@define AC_flag 	"PSW[4,1]"  # Auxiliary Carry Flag (AC)
@define RBS0_flag	"PSW[3,1]" 	# Register Bank Select Lo-Bit (RBS0)
@define ISP1_flag 	"PSW[2,1]" 	# In-service priority flag Hi-Bit (ISP1)
@define ISP0_flag 	"PSW[1,1]"  # In-service priority flag Lo-Bit (ISP0)
@define CY_flag 	"PSW[0,1]"  # Carry flag (CY)

#########################################################################
#
# Pseudocode ops
#
#########################################################################

#define pcodeop skip;
define pcodeop todo;
define pcodeop halt;
define pcodeop stop;
define pcodeop invalid;

#########################################################################
#
# Operand data types
#
# FYI: You can think of sleigh tokens as both bitfields and parser 
# 	   directives. Basically, a token is any element that is a potential
# 	   sub-field you may want to parse out of an instruction, and the 
# 	   attach keyword is used to turn those parsed fields into
#	   elements of a register map cleanly.
#
#########################################################################

define token op1b (8) 
	op1b_byte = (0,7)

	op1b_hi = (4,7)
	op1b_lo = (0,3)
	op1b_lo3 = (0,2)

	op1b_reg0 = (0,2)
	op1b_reg_4_5 = (4,5)
	op1b_reg0_dupe = (0,2)
	op1b_2xreg = (1,2)
	op1b_2xreg_dupe = (1,2) #duplicate to check val
	op1b_reg_dehl = (1,1) #special namespace for mov operations
					   #which are limited to DE and HL r/w.
					   #This includes all mem load/store ops.
	op1b_reg_axbc = (0,0) #special namespace for clrw & co, only uses ax/bc
	op1b_movw_rp = (4,5)
	op1b_movw_rp_dupe = (4,5)
	op1b_reg_rp = (1,2)
	op1b_reg_rp_dupe = (1,2)
	op1b_movr = (4,5)
	op1b_movr_dupe = (4,5)
	op1b_setb_reg0 = (0,1) #special namespace for ONEB/CLRB

	op1b_b7 = (7,7)
	op1b_b6 = (6,6)
	op1b_b5 = (5,5)
	op1b_b4 = (4,4)
	op1b_b3 = (3,3)
	op1b_b2 = (2,2)
	op1b_b1 = (1,1)
	op1b_b0 = (0,0)
;

define token op2b (8)
	op2b_byte = (0,7)
	op2b_hi = (4,7)
	op2b_hi_val = (4,7) #duplicate to check val without causing issues
	op2b_lo = (0,3)
	op2b_sfr = (0,2)
	op2b_sfrp = (0,1)

	op2b_b7 = (7,7)
	op2b_b6 = (6,6)
	op2b_b3 = (3,3)
	op2b_b2 = (2,2)

	op2b_reg0 = (0,2)
	op2b_reg0_dupe = (0,2)
	op2b_reg_rbsel = (4,5)

	op2b_reg_rp = (4,5)

	op2b_hi2 = (6,7)
	op2b_bit_sel = (4,6)
;

define token calltref (8)
	calltref_b7 = (7,7)
	calltref_hi = (4,6)
	calltref_b3 = (3,3)
	calltref_b2 = (2,2)
	calltref_lo = (0,1)
;

define token op3b (8)	
	op3b_byte = (0,7)
	op3b_sfr = (0,2)
	op3b_hi = (4,7)
	op3b_lo = (0,3)
	op3b_b3 = (3,3)
;

define token esbyte (8)
	esmarker = (0,7)
;

define token data8 (8)
	uadr8 = (0,7)
	adr8_dupe = (0,7)
	disp8 = (0,7) signed
	adr8 = (0,7) signed
	imm8 = (0,7)
	simm8 = (0,7) signed
;

define token data16 (16)
	disp16 = (0,15) signed
	imm16 = (0,15)
	imm16_lo = (0,7)
	imm16_hi = (8,15)
	simm16 = (0,15) signed
;

define token data24 (24)
	imm24 = (0,23)
;

attach variables [op1b_reg0 op2b_reg0] 		[X A C B E D L H];
attach variables [op1b_2xreg op2b_reg_rp]	[AX BC DE HL];
attach variables [op2b_sfr op3b_sfr]		[SPL SPH PSW _ CS ES PMC MEM];
attach variables [op1b_reg_dehl]			[DE HL];
attach variables [op1b_reg_axbc]			[AX BC];
attach variables [op2b_sfrp]				[SP      _     _     _      ];
attach variables [op1b_reg_4_5]				[_ B C _];
attach variables [op1b_reg_rp]				[_ DE HL _];
attach variables [op1b_movw_rp]				[_ BC DE HL];
attach variables [op1b_movr]				[_ X B C];
attach variables [op1b_setb_reg0]			[X A C B];


##########################################################################
#
# Macros
#
##########################################################################

#macro push16(val16) {
#	SP = SP - 2;
#	ptr:$(PTRSIZE) = SP;
#	*:2 ptr = val16; 
#}



macro addw_set_flags(val1, val2){
	local tmp1:2;
	local tmp2:2;
	tmp1 = (val1>>15)&0x1;
	tmp2 = (val2>>15)&0x1;
	$(CY_flag) = tmp1[0,1] & tmp2[0,1];
	$(Z_flag) = (val1 == (-val2));
	$(AC_flag) = 0;
}

macro add_set_flags(val1, val2){
	$(CY_flag) = ((val1>>7)&0x1) & ((val2>>7)&0x1);
	$(Z_flag)  = (val1 == (-val2));
	local tmp:1 = 0x0;
	tmp = val1[0,3] + val2[0,3];
	tmp = (tmp >> 3) & 0x1;
	$(AC_flag) = tmp;
}

macro sr_set_flags16(reg, imm){
	local tmp:2 = (reg >> imm) & 0x1:2;
	local tmp2:1 = tmp[0,7];
	$(CY_flag) = tmp2;
}

macro sr_set_flags8(reg, imm){
	local tmp:1 = (reg >> imm) & 0x1:1;
	$(CY_flag) = tmp;
}

macro read_byte(dst, addr){
	ptr:$(PTRSIZE) = 0x0;
	ptr[0, 16] = addr[0,16];
	ptr[16, 4] = 0xF;
	dst = *:1 ptr;
}

macro read_stack_byte(dst, addr){
	ptr:$(PTRSIZE) = 0x0;
	ptr[0, 16] = addr[0,16];
	ptr[16, 4] = 0xF;
	dst = *:1 ptr;
}

macro read_es_byte(dst, addr){
	ptr:$(PTRSIZE) = 0x0; 
	ptr[0, 16] = ptr[0, 16] | addr;
	ptr[16, 4] = ptr[16, 4] | ES[0, 4];
	dst = *:1 ptr;
}

macro write_byte(src, addr){
	ptr:$(PTRSIZE) = 0x0F0000;
	ptr[0,16] = ptr[0,16] | addr;
	*:1 ptr = src;
}

macro write_stack_byte(src, addr){
	local ptr:$(PTRSIZE) = 0x0F0000;
	ptr[0, 16] = addr[0,16];
	*:1 ptr = src;
}

#macro write_es_byte(src, addr){}

#TODO: check if base for mem reads is 0xF or 0x0, 
#		datasheet and ODA seem to disagree. 
macro read_word(dst, addr){
	local dst_lo:2 = 0x0;
	local dst_hi:2 = 0x0;
	ptr:$(PTRSIZE) = 0x0; 
	ptr[0, 16] = addr[0,16];
	ptr[16, 4] = 0xF;
	dst_lo = *:1 ptr;
	ptr = ptr + 1;
	dst_hi = *:1 ptr;
	dst = ((dst_hi << 8)| dst_lo);
}

macro write_word(src, addr){
	local src_lo:1 = 0x0;
	local src_hi:1 = 0x0;
	ptr:$(PTRSIZE) = 0x0;
	ptr[0, 16] = addr[0,16];
	ptr[16, 4] = 0xF;
	src_lo = src[0,8];
	src_hi = src[8,8];
	*:1 ptr = src_lo;
	ptr = ptr + 1;
	*:1 ptr = src_hi;
}

macro write_stack_word(src, addr){
	#TODO: replace all write_stack_word uses with push_word uses
	local src_lo:1 = 0x0;
	local src_hi:1 = 0x0;
	ptr:$(PTRSIZE) = 0x0;
	ptr[0, 16] = addr[0,16];
	ptr[16, 4] = 0xF;
	src_lo = src[0,8];
	src_hi = src[8,8];
	*:1 ptr = src_lo;
	ptr = ptr + 1;
	*:1 ptr = src_hi;
}

macro push(src){
	SP = SP - 2;
	*[stackarea]:2 SP = src;
}

macro pop(dst){
	dst = *[stackarea]:2 SP;
	SP = SP + 2;
}

macro pushpc(pc, inter){
	SP = SP - 3;
	*[stackarea]:3 SP = pc:3;
	SP = SP - 1;
	*[stackarea]:1 SP = inter:1;
}

macro poppc(pc, inter){
	inter = *[stackarea]:1 SP;
	SP = SP + 1;
	pc = *[stackarea]:3 SP;
	SP = SP + 3;
}

macro push_word(src){
	SP = SP - 2;
	ptr:$(PTRSIZE) = 0x0;
	ptr[0, 16] = SP;
	ptr[16, 4] = 0xF;
	*:2 ptr = SP;
}


macro read_stack_word(dst, addr){
	local dst_lo:2 = 0x0;
	local dst_hi:2 = 0x0;
	ptr:$(PTRSIZE) = 0x0; 
	ptr[0, 16] = addr;
	ptr[16, 4] = 0xF;
	dst_lo = *:1 ptr;
	ptr = ptr + 1;
	dst_hi = *:1 ptr;
	dst = ((dst_hi << 8)| dst_lo);
}

macro pop_word(dst){
	#TODO: replace all read_stack_word uses with pop_word
	ptr:$(PTRSIZE) = 0x0; 
	ptr[0, 16] = SP;
	ptr[16, 4] = 0xF;
	dst = *:2 ptr;
	SP = SP + 2;
}

macro cmp8_set_flags(arg1, arg2){
	$(Z_flag) = ((arg2 - arg1) == 0);
	$(CY_flag) = ((arg2 & 0x7f) < (arg1 & 0x7f));
	$(AC_flag) = ((arg2 & 0x07) < (arg1 & 0x07));
}

macro cmpw_set_flags(arg1, arg2){
	$(Z_flag) = (arg2 == arg1);
}

macro subw_set_flags(dst, src){
	$(AC_flag) = 0;
	$(Z_flag) = (dst == src);
	$(CY_flag) = (dst < src);
}

macro bit_set_to(val, bit_index, set_to){
	local mask = ~(0x1 << bit_index);
	val = val & mask;
	val = val|(set_to<<bit_index);
}

macro bit_get(val, bit_index, dst){
	local tmp = (val>>bit_index);
	dst = (tmp & 0x1);
}

#TODO: can I turn the 2 macro's below into 1? don't see why not?
macro reg_stackarea_offset8(saptr, ptr_reg, adr){
	saptr = 0x0F0000;
	local tmp:3 = saptr | zext(ptr_reg);
	saptr = tmp + adr;
}

macro reg_stackarea_offset16(saptr, ptr_reg, adr){
	saptr = 0x0F0000;
	local tmp:3 = saptr | zext(ptr_reg);
	saptr = tmp + adr;
}

#TODO: fix up all the mangled references
#		This was based off the z80 slaspec, but they screwed up the handling real bad.
#		Export *: doesn't export a pointer, it exports a reference which ghiddra converts
#		into a pointer down the road, and the z80 guys didnt seem to get that. add
#		TODO: replace all addr16 with add16_1x or add16_2x
RelAddr8: loc  is simm8  [ loc = inst_next + simm8; ]        
		{ export *:1 loc; }
		#{ export *:$(PTRSIZE) loc; }

jdisp16: loc is disp16 	 [ loc = inst_next + disp16; ]
		{ export *:1 loc; }

addr16:   loc is imm16 [ loc = 0xf0000 + imm16;]	
		{ export *:$(PTRSIZE) loc; }

addr16_1x:   loc is imm16 [ loc = 0xf0000 + imm16;]	
		{ export *:1 loc; }

addr16_2x: 	 loc is imm16 [ loc = 0xf0000 + imm16;]
		{ export *:2 loc;}

jaddr16:  loc is imm16 [ loc = 0x00000 | imm16;]
		{ export *:1 loc; }

jaddr20: loc is imm24 [ loc = imm24&0x0FFFFF; ]
		{ export *:1 loc; }

callt_addr: ["vector_table:"adr] is calltref_b7=1 & calltref_hi & calltref_b3=0 & calltref_b2=1 & calltref_lo
[
	adr = 0x80 | ((calltref_hi<<1) | (calltref_lo<<4));
]
{
	local newadr:3 = 0x0:3 | zext(adr:1);
	local table_deref:2 = *:2 newadr;
	local jmptarget:$(PTRSIZE) = zext(table_deref);
	export *:1 jmptarget;
}

#also called saddr in data sheet? wait no i think i was wrong -- need to fix this
#TODO: separate sfr and sadr calls
#TODO: replace messy sfr/sfrp invocations
sfr: op2b_sfr is op2b_hi=0xF & op2b_b3=1 & op2b_sfr { export op2b_sfr; }

sfrp: op2b_sfrp is op2b_hi=0xF & op2b_b3=1 & op2b_b2=0 & op2b_sfrp { export op2b_sfrp; }

sfr_raw1: "sfr:"loc is uadr8 [loc = 0x0FFF00 + uadr8; ]
		{  export *[ram]:1 loc; }

sfr_raw2: "sfr:"loc is uadr8 [ loc = 0x0FFF00 + uadr8; ]
		{ export *[ram]:2 loc; }


#TODO: fix the range for which saddr/saddrp is accessible. See G13 docs, page 158
saddr: 	loc is uadr8 [ loc = 0xFFF00 + uadr8; ]
		{ export *[ram]:1 loc; }

saddrp: loc is uadr8 [ loc = 0xFFF00 + uadr8; ]
		{ export *[ram]:2 loc; }

#TODO: add prefix operand to remove need for esmarker=0x11
#TODO: replace all [HL+x] calls with hl_offset
#TODO: figure out how to clean these up so that ghidra is less weird about offsets during disasm.
#TODO: check if you screwed up with the offsets. seemm better now, but still need quadruple checking

#TODO: collapse # of argument definitions using context registers?
es_hl_b_byte: ES:[HL+B] is HL & B & ES
		{ local ptr = 0:3;
		  ptr[0,16] = HL + sext(B);
		  ptr[16,4] = ES[0,4]; 
		  export *:1 ptr; }

es_addr16_byte: ES:!imm16 is imm16 & ES 
		{ local ptr = 0:3;
		  ptr[0,16] = imm16;
		  ptr[16,4] = ES[0,4]; 
		  export *:1 ptr; }

es_addr16_word: ES:!imm16 is imm16 & ES
		{ local ptr = 0:3;
		  ptr[0,16] = imm16;
		  ptr[16,4] = ES[0,4]; 
		  export *:2 ptr; }

es_hl_ofst_byte: ES:[HL+adr8] is adr8 & ES & HL
		{ local ptr:$(PTRSIZE) = 0x0;
		  ptr[16,4] = ES[0,4];
		  ptr[0,16] = HL;
		  ptr = ptr + sext(adr8:1);
		  export *:1 ptr; }

hl_ptr_byte: [HL] is HL 
		{ local ptr:$(PTRSIZE) = 0xF0000;
		  ptr = ptr | zext(HL);
		  export *:1 ptr;}

hl_ptr_word: [HL] is HL
		{ local ptr:$(PTRSIZE) = 0xF0000;
		  ptr = ptr | zext(HL);
		  export *:2 ptr;}

hl_offset: [HL+disp8] is disp8 & HL 
		{ local tmp:2 = HL + sext(disp8:1);
		  local loc:3 = 0xF0000:3 | zext(tmp);
		  export *[ram]:1 loc; }

hl_offset_word: [HL+disp8] is disp8 & HL 
		{ local tmp:2 = HL + sext(disp8:1);
		  local loc:3 = 0xF0000:3 | zext(tmp);
		  export *[ram]:2 loc; }

b_offset_byte: disp16[B] is disp16 & B
		{ local tmp:2 = disp16 + sext(B);
		  local loc:3 = 0xF0000:3 | zext(tmp);
		  export *[ram]:1 loc; }

b_offset_word: disp16[B] is disp16 & B
		{ local tmp:2 = disp16 + sext(B);
		  local loc:3 = 0xF0000:3 | zext(tmp);
		  export *[ram]:2 loc; }

c_offset_byte: disp16[C] is disp16 & C
		{ local tmp:2 = disp16 + sext(C);
		  local loc:3 = 0xF0000:3 | zext(tmp);
		  export *[ram]:1 loc; }

c_offset_word: disp16[C] is disp16 & C
		{ local tmp:2 = disp16 + sext(C);
		  local loc:3 = 0xF0000:3 | zext(tmp);
		  export *[ram]:2 loc; }

bc_offset_word: disp16[BC] is disp16 & BC
		{ local tmp:2 = BC + disp16;
		  local loc:3 = 0xF0000:3 | zext(tmp);
		  export *[ram]:2 loc; }
		#{ local tmp:3 = 0xF0000:3 + zext(BC:2);
		#  local loc:3 = tmp + sext(disp16:2);
		#  export *[ram]:2 loc;}

sp_offset_byte: [SP+disp8] is disp8 & SP
		{ local loc:2 = sext(disp8:1) + SP;
		  export *[stackarea]:1 loc; 
		}

sp_offset_word: [SP+disp8] is disp8 & SP
		{ local loc:2 = sext(disp8:1) + SP;
		  export *[stackarea]:2 loc; 
		}

##########################################################################
#
# Instructions
#
##########################################################################

#:MOV
#TODO: The rest of MOV
:MOV op1b_reg0," #"imm8	is op1b_hi=0x5 & op1b_b3!=0x1 & op1b_reg0; imm8 {
	op1b_reg0 = imm8;
}

:MOV A,op1b_reg0 		is op1b_hi=0x6 & op1b_b3!=0x1 & op1b_reg0 & op1b_lo3!=0x1 & A {
	A = op1b_reg0;
}

:MOV op1b_reg0,A		is op1b_hi=0x7 & op1b_b3!=0x1 & op1b_reg0 & op1b_lo3!=0x1 & A {
	op1b_reg0 = A;
}

:MOV op2b_sfr,A 		is op1b_byte=0x9E; op2b_hi=0xF & op2b_b3=0x1 & op2b_sfr & A {
	op2b_sfr = A;
}

:MOV op2b_sfr,"#"imm8 	is op1b_byte=0xCE; op2b_hi=0xF & op2b_b3=0x1 & op2b_sfr; imm8
{
	op2b_sfr = imm8;
}

:MOV sfr_raw1,"#"imm8 	is op1b_byte=0xCE; sfr_raw1 & adr8_dupe<0xF0; imm8 
{
	sfr_raw1 = imm8;
}

:MOV sfr_raw1,"#"imm8 	is op1b_byte=0xCD; sfr_raw1; imm8 
{
	sfr_raw1 = imm8;
}


:MOV [op1b_reg_dehl],A 	is op1b_hi=0x9 & op1b_b3=1 & op1b_b2=0 & op1b_reg_dehl & op1b_b0=1 & A 
{
	write_byte(A, op1b_reg_dehl);
}

:MOV A,"["op1b_reg_dehl"]" is op1b_hi=0x8 
			& op1b_b3=1 & op1b_b2=0 & op1b_reg_dehl & op1b_b0=1 & A
{
	read_byte(A, op1b_reg_dehl);
}

#todo: confirm that offset is calculated correctly here. seems like its not.
:MOV A,ES":["op1b_reg_dehl"]" is esmarker=0x11; 
			op1b_hi=0x8 & op1b_b3=1 & op1b_b2=0 & op1b_reg_dehl & op1b_b0=1
			& A & ES
{
	read_es_byte(A, op1b_reg_dehl);
}

:MOV ES,"#"imm8 		is op1b_byte=0x41; imm8 & ES
{
	ES = imm8;
}

:MOV A,imm16[BC] 		is op1b_byte=0x49; imm16 & A & BC {
	addr:2 = BC + imm16;
	read_byte(A, addr);
}

:MOV [op1b_reg_rp+adr8],"#"imm8 	is op1b_hi=0xC & op1b_b3=1 & op1b_reg_rp & op1b_b0=0; adr8; imm8
{
	local ptr:$(PTRSIZE) = 0x000000;
	reg_stackarea_offset8(ptr, op1b_reg_rp, adr8);
	*:1 ptr = imm8;
}

:MOV [op1b_reg_rp+adr8],A 		is op1b_hi=0x9 & op1b_b3=1 & op1b_reg_rp & op1b_b0=0; adr8 & A
{
	local ptr:$(PTRSIZE) = 0x0;
	reg_stackarea_offset8(ptr, op1b_reg_rp, adr8);
	*:1 ptr = A;
}

:MOV A,[op1b_reg_rp+adr8] 		is op1b_hi=0x8 & op1b_b3=1 & op1b_reg_rp & op1b_b0=0 & (op1b_reg_rp_dupe=1 | op1b_reg_rp_dupe=2); adr8 & A
{
	local ptr:$(PTRSIZE) = 0x0;
	reg_stackarea_offset8(ptr, op1b_reg_rp, adr8);
	A = *:1 ptr;
}

:MOV A,sfr_raw1			is op1b_byte=0x8E; sfr_raw1 & A 
{
	A = sfr_raw1;
}

:MOV sfr_raw1,A 			is op1b_byte=0x9E; sfr_raw1 & A 
{
	sfr_raw1 = A;
}

:MOV A,!addr16_1x			is op1b_byte=0x8F; addr16_1x & A
{
	A = addr16_1x;
}

:MOV !addr16, A 		is op1b_byte=0x9F; addr16 & A
{
	*:1 addr16 = A;
}

:MOV !addr16_1x,"#"imm8 	is op1b_byte=0xCF; addr16_1x; imm8
{
	addr16_1x = imm8;
}

:MOV op1b_movr,!addr16_1x 	is op1b_b7=1 & op1b_b6=1 & op1b_movr & op1b_lo=0x9 & 
					op1b_movr_dupe!=0; addr16_1x
{
	op1b_movr = addr16_1x;
}

:MOV op1b_movr,es_addr16_byte 	is esmarker=0x11; op1b_b7=1 & op1b_b6=1 & op1b_movr & op1b_lo=0x9 & 
					op1b_movr_dupe!=0; es_addr16_byte
{
	op1b_movr = es_addr16_byte;
}


:MOV op1b_movr,sfr_raw1 	is op1b_b7=1 & op1b_b6=1 & op1b_movr & op1b_lo=0x8 &
					op1b_movr_dupe!=0; sfr_raw1
{
	op1b_movr = sfr_raw1;
}

:MOV A,saddr  				is op1b_byte=0x8D; saddr & A
{
	A=saddr;
}

:MOV saddr,A 				is op1b_byte=0x9D; saddr & A
{
	saddr=A;
}

:MOV b_offset_byte,"#"imm8		is op1b_byte=0x19; b_offset_byte; imm8
{
	b_offset_byte=imm8;
}

:MOV A,b_offset_byte			is op1b_byte=0x09; b_offset_byte & A
{
	A = b_offset_byte;
}

:MOV b_offset_byte,A 			is op1b_byte=0x18; b_offset_byte & A
{
	b_offset_byte = A;
}

:MOV sp_offset_byte,A 			is op1b_byte=0x98; sp_offset_byte & A
{
	sp_offset_byte = A;
}

:MOV A,sp_offset_byte 			is op1b_byte=0x88; sp_offset_byte & A
{
	A=sp_offset_byte;
}

:MOV c_offset_byte,"#"imm8 		is op1b_byte=0x38; c_offset_byte; imm8
{
	c_offset_byte=imm8;
}

:MOV A,es_addr16_byte 			is esmarker=0x11; op1b_byte=0x8F; es_addr16_byte & A
{
	A = es_addr16_byte;
}

:MOV A,es_hl_b_byte 			is esmarker=0x11; op1b_byte=0x61; op2b_byte=0xC9 & A & es_hl_b_byte
{
	A = es_hl_b_byte;
}

:MOV c_offset_byte,A 			is op1b_byte=0x28; c_offset_byte & A
{
	c_offset_byte=A;
}

#:TODO: *
#:XCH
# 		XCH A, X
macro inst_xch(dst, src){
	local tmp = dst;
	dst = src;
	src = tmp;
}

:XCH A,X 					is op1b_byte=0x08 & A & X
{
	inst_xch(A, X);
}

:XCH A,op2b_reg0 			is op1b_byte=0x61; op2b_reg0 & op2b_reg0_dupe>1 & A
{
	inst_xch(A, op2b_reg0);
}

#:ONEB
#TODO: etc
#DONE: ONEB !addr16
#		oneb, xacb
# 		ONEB saddr
:ONEB !addr16_1x 			is op1b_byte=0xE5; addr16_1x
{
	addr16_1x = 0x1:1;
}

:ONEB op1b_setb_reg0		is op1b_hi=0xE & op1b_b3=0 & op1b_b2=0 & op1b_setb_reg0
{
	op1b_setb_reg0 = 0x1:1;
}

:ONEB saddr 		is op1b_byte=0xE4; saddr
{
	saddr = 0x1:1;
}

#:CLRB
#TODO: CLRB ES:!addr16
:CLRB !addr16_1x 		is op1b_byte=0xF5; addr16_1x
{
	addr16_1x = 0x00;
}

:CLRB saddr 			is op1b_byte=0xF4; saddr
{
	saddr = 0x00;
}


:CLRB op1b_setb_reg0 	is op1b_hi=0xF & op1b_b3=0 & op1b_b2=0 & op1b_setb_reg0
{
	op1b_setb_reg0 = 0x00;
}

#:MOVS

#:MOVW
#TODO: The rest of MOVW
#	we've done: movw imm16 into reg pair
# 				movw from regpair to AX
#				movw from AX to regpair
#				movw sfrp,#word
#				movw addr16,ax
#				movw ax,addr16
#				movw imm16[r], ax
#				movw ax, 1mm16[r]
#				movw rp, !imm16
#				movw [dehl], ax
#				movw ax, [dehl]
#				movw sfrp, #word
#				movw AX, [hl+byte]
#				movw [hl+byte], AX
#				movw sfrp, AX
#				movw AX, sfrp
#				movw ax, saddrp
#				movw saddrp, AX
#				movw bc/de/hl, saddrp
#				movw imm16[rp], ax
#				movw ax, imm16[rp]
#				movw saddrp, word
#				movw AX, [SP+addr8]
#				movw [SP+addr8], AX
#				movw HL, ES:!addr16
:MOVW op1b_2xreg," #"imm16 	is op1b_hi=0x3 & op1b_b3=0 & op1b_2xreg & op1b_b0=0; imm16{
	op1b_2xreg = imm16;
}

:MOVW AX,op1b_2xreg 		is op1b_hi=0x1 & op1b_b3=0 & op1b_2xreg & op1b_b0=1 & op1b_2xreg_dupe!=0x0 & AX {
	AX = op1b_2xreg;
}

:MOVW op1b_2xreg,AX		is op1b_hi=0x1 & op1b_b3=0 & op1b_2xreg & op1b_b0=0 & op1b_2xreg_dupe!=0x0 & AX {
	op1b_2xreg = AX;
}

:MOVW op2b_sfrp,"#"imm16 is op1b_byte=0xCB; op2b_hi=0xF & op2b_b3=1 & op2b_b2=0 & op2b_sfrp; imm16
{
	op2b_sfrp=imm16;
}

:MOVW AX,!addr16		is op1b_byte=0xAF; addr16 & AX
{
	AX = *:2 addr16;
}

:MOVW !addr16_2x,AX 		is op1b_byte=0xBF; addr16_2x & AX
{
	addr16_2x = AX;
}

#TODO: can we combine b_offset_word and c_offset_word into 1 arg to reduce instruction definition count?
:MOVW b_offset_word,AX 			is op1b_byte=0x58; b_offset_word & AX
{
	b_offset_word = AX;
}

:MOVW c_offset_word,AX 			is op1b_byte=0x68; c_offset_word & AX
{
	c_offset_word = AX;
}

:MOVW AX,b_offset_word 			is op1b_byte=0x59; b_offset_word & AX
{
	AX = b_offset_word;
}

:MOVW AX,c_offset_word 			is op1b_byte=0x69; c_offset_word & AX
{
	AX = c_offset_word;
}

:MOVW op1b_movw_rp,!addr16 		is op1b_b7=1 & op1b_b6=1 & op1b_movw_rp & op1b_lo=0xB & op1b_movw_rp_dupe!=0; addr16
{
	op1b_movw_rp = *:2 addr16;
}

:MOVW AX,[op1b_reg_dehl]		is op1b_hi=0xA & op1b_b3=1 & op1b_b2=0 & op1b_reg_dehl & op1b_b0=1 & AX
{
	read_word(AX, op1b_reg_dehl);
}

:MOVW [op1b_reg_dehl],AX 		is op1b_hi=0xB & op1b_b3=1 & op1b_b2=0 & op1b_reg_dehl & op1b_b0=1 & AX
{
	write_word(AX, op1b_reg_dehl);
}

:MOVW sfr_raw2,"#"imm16 		is op1b_byte=0xCB; sfr_raw2; imm16
{
	sfr_raw2 = imm16;
}

:MOVW AX,[HL+adr8]				is op1b_byte=0xAC; adr8 & AX & HL
{
	local ptr:$(PTRSIZE) = 0;
	reg_stackarea_offset8(ptr, HL, adr8);
	AX = *:2 ptr;
}

:MOVW [HL+adr8],AX 				is op1b_byte=0xBC; adr8 & AX & HL
{
	local ptr:$(PTRSIZE) = 0;
	reg_stackarea_offset8(ptr, HL, adr8);
	*:2 ptr = AX;
}

:MOVW AX,[DE+adr8] 				is op1b_byte=0xAA; adr8 & AX & DE
{
	local ptr:$(PTRSIZE) = 0;
	reg_stackarea_offset8(ptr, DE, adr8);
	AX = *:2 ptr;
}

:MOVW [DE+adr8],AX 				is op1b_byte=0xBA; adr8 & AX & DE
{
	local ptr:$(PTRSIZE) = 0;
	reg_stackarea_offset8(ptr, DE, adr8);
	*:2 ptr = AX;
}

:MOVW sfrp,AX 				is op1b_byte=0xBE; sfrp & AX
{
	sfrp = AX;
}

:MOVW sfr_raw2,AX 			is op1b_byte=0xBE; sfr_raw2 & AX
{
	sfr_raw2 = AX;
}

:MOVW AX,sfrp 				is op1b_byte=0xAE; sfrp & AX
{
	AX = sfrp;
}

:MOVW AX,sfr_raw2 			is op1b_byte=0xAE; sfr_raw2 & AX
{
	AX = sfr_raw2;
}

:MOVW saddrp,AX 			is op1b_byte=0xBD; saddrp & AX
{
	saddrp = AX;
}

:MOVW AX,saddrp 			is op1b_byte=0xAD; saddrp & AX
{
	AX = saddrp;
}

:MOVW op1b_movw_rp,saddrp			is op1b_b7=1 & op1b_b6=1 & op1b_movw_rp & op1b_lo=0xA; saddrp
{
	op1b_movw_rp = saddrp;
}

:MOVW AX,bc_offset_word 			is op1b_byte=0x79; bc_offset_word & AX
{
	AX = bc_offset_word;
}

:MOVW bc_offset_word,AX 			is op1b_byte=0x78; bc_offset_word & AX
{
	bc_offset_word = AX;
}

:MOVW saddrp,"#"imm16 				is op1b_byte=0xC9; saddrp; imm16
{
	saddrp = imm16;
}

:MOVW AX,sp_offset_word					is op1b_byte=0xA8; sp_offset_word & AX
{
	AX = sp_offset_word;
}

:MOVW sp_offset_word,AX 					is op1b_byte=0xB8; sp_offset_word & AX
{
	sp_offset_word = AX;
}

:MOVW HL,es_addr16_word 			is esmarker=0x11; es_addr16_word & HL
{
	HL = es_addr16_word;
}


:XCHW AX,op1b_2xreg 				is op1b_hi=0x3 & op1b_b3=0 & op1b_2xreg & op1b_b0=1 & AX
{
	local tmp:2 = AX;
	AX = op1b_2xreg;
	op1b_2xreg=tmp;
}

:ONEW op1b_reg_axbc 		is (op1b_byte=0xE6 | op1b_byte=0xE7) & op1b_reg_axbc
{
	op1b_reg_axbc = 0x0001:2;
}

:CLRW op1b_reg_axbc 		is (op1b_byte=0xF6 | op1b_byte=0xF7) & op1b_reg_axbc
{
	op1b_reg_axbc = 0x0000:2;
}

#:ADD
#TODO: All of add except ADD reg, reg
# 						ADD A, imm8
#						ADD A, [hl+adr8]
# 						ADD saddr, imm8
:ADD A,op2b_reg0 		is op1b_byte=0x61; op2b_hi=0x0 & op2b_b3=1 & op2b_reg0 & op2b_reg0_dupe!=0x1 & A
{
	add_set_flags(A, op2b_reg0);
	A = A + op2b_reg0;
}

:ADD op2b_reg0, A			is op1b_byte=0x61; op2b_hi=0x0 & op2b_b3=0 & op2b_reg0 & A
{
	add_set_flags(op2b_reg0, A);
	op2b_reg0 = op2b_reg0 + A;
}

:ADD A,"#"imm8 				is op1b_byte=0x0C; imm8 & A
{
	add_set_flags(A, imm8:1);
	A = A + imm8;
}

:ADD A,hl_offset 			is op1b_byte=0x0E; hl_offset & A
{
	add_set_flags(A, hl_offset);
	A = A + hl_offset;
}

:ADD saddr,"#"imm8			is op1b_byte=0x0A; saddr; imm8
{
	add_set_flags(saddr, imm8:1);
	saddr = saddr + imm8;
}

#TODO: *
#DONE:  ADDC A, r
#		ADDC r, A
# 		A, #byte
# 		ADDC saddr, imm8
:ADDC A,op2b_reg0 			is op1b_byte=0x61; op2b_hi=0x1 & op2b_b3=1 & op2b_reg0 & op2b_reg0_dupe!=1 & A
{
	local tmp:1 = op2b_reg0 + $(CY_flag);
	add_set_flags(A, tmp);
	A = A + tmp;
}

:ADDC op2b_reg0,A 			is op1b_byte=0x61; op2b_hi=0x1 & op2b_b3=0 & op2b_reg0 & A
{
	local tmp:1 = op2b_reg0 + $(CY_flag);
	add_set_flags(tmp, A);
	op2b_reg0 = A + tmp;
}

:ADDC A,"#"imm8 			is op1b_byte=0x1C; imm8 & A
{
	local tmp:1 = A + $(CY_flag);
	add_set_flags(tmp, imm8:1);
	A = tmp + imm8;

}

:ADDC saddr,"#"imm8 		is op1b_byte=0x1A; saddr; imm8
{
	add_set_flags(saddr, imm8:1);
	saddr = saddr + imm8;
}

#:SUB
#TODO: figure out AC and CY? CY is prolly wrong here anyway
#TODO: *
#DONE: 	sub a, [hl+byte]
#		sub a, r
#		sub r, a
#		sub A, !addr16
#		SUB A, ES:[HL+B]
macro inst_sub(dst, src){
	local tmp:1 = dst - src;
	$(Z_flag) = (tmp == 0);
	local neg_src = -src;
	$(CY_flag) = dst[7,1] & neg_src[7,1];
	dst = dst - src;
}
:SUB A,hl_offset 			is op1b_byte=0x2E; hl_offset & A
{
	inst_sub(A, hl_offset);
}

:SUB A,op2b_reg0 			is op1b_byte=0x61; op2b_hi=0x2 & op2b_b3=1 & op2b_reg0 & op2b_reg0_dupe!=1 & A
{
	inst_sub(A,op2b_reg0);
}

:SUB op2b_reg0,A 			is op1b_byte=0x61; op2b_hi=0x2 & op2b_b3=0 & op2b_reg0 & A
{
	inst_sub(op2b_reg0,A);
}

:SUB A,!addr16_1x 			is op1b_byte=0x2F; addr16_1x & A
{
	inst_sub(A, addr16_1x);
}

:SUB A,es_hl_b_byte 		is esmarker=0x11; op1b_byte=0x61; op2b_byte=0xA0 & A & es_hl_b_byte
{
	inst_sub(A, es_hl_b_byte);
}

#:SUBC
#TODO: *
#DONE: 	SUBC A,r
#		SUBC r,A
#		SUBC saddr,imm8
#		SUBC A,saddr
macro inst_subc(dst, src){
	#TODO: figure out how tf the AC flag actually works
	local tmp:1 = dst - src;
	tmp = tmp - $(CY_flag);
	$(Z_flag) = (tmp == 0);
	local neg_src_p1:1 = src + 1;
	neg_src_p1 = -1*neg_src_p1;
	$(CY_flag) = (dst[7,1] & neg_src_p1[7,1]);
	dst = tmp;
}

:SUBC A,op2b_reg0 			is op1b_byte=0x61; op2b_hi=0x3 & op2b_b3=1 & op2b_reg0 & op2b_reg0_dupe!=1 & A
{
	inst_subc(A,op2b_reg0);
}

:SUBC op2b_reg0,A 			is op1b_byte=0x61; op2b_hi=0x3 & op2b_b3=0 & op2b_reg0 & A
{
	inst_subc(op2b_reg0,A);
}

:SUBC saddr,"#"imm8			is op1b_byte=0x3A; saddr; imm8
{
	inst_subc(saddr,imm8);
}

:SUBC A,saddr 				is op1b_byte=0x3B; saddr & A
{
	inst_subc(A,saddr);
}

#:AND
#TODO: ~DONE
#DONE: and A, #imm8
#		and A, saddr
#		and a, addr16_1x
#		and a [hl+byte]
# 		and saddr, #byte
# 		and reg, A
#		and A, reg
macro inst_and(dst, src){
	local tmp = dst & src;
	$(Z_flag) = (tmp == 0);
	dst = tmp;
}
:AND A,"#"imm8				is op1b_byte=0x5C; imm8 & A
{
	inst_and(A,imm8);
}

:AND A,sfr_raw1 			is op1b_byte=0x5B; sfr_raw1 & A 
{
	inst_and(A,sfr_raw1);
}

:AND A,addr16_1x 			is op1b_byte=0x5F; addr16_1x & A
{
	inst_and(A,addr16_1x);
}

:AND A,hl_offset 			is op1b_byte=0x5E; hl_offset & A
{
	inst_and(A,hl_offset);
}

:AND saddr,"#"imm8 			is op1b_byte=0x5A; saddr; imm8
{
	inst_and(saddr,imm8);
}

:AND A,op2b_reg0 			is op1b_byte=0x61; op2b_hi=0x5 & op2b_b3=1 & op2b_reg0 & op2b_reg0_dupe!=1 & A
{
	inst_and(A, op2b_reg0);
}

:AND op2b_reg0,A 			is op1b_byte=0x61; op2b_hi=0x5 & op2b_b3=0 & op2b_reg0 & A
{
	inst_and(op2b_reg0, A);
}

#:OR
#TODO: more macros for instructions in this style. way cleaner. 
#TODO: add documentation of instructions at each instruction
#TODO: *
#DONE: or saddr, #byte
#		or A, #byte
# 		or A, reg
# 		or reg, A
# 		or A, [hl+byte]
#		or A, !addr16
#		or A, saddr
macro inst_or(dst, src){
	local tmp = 0x0;
	tmp = dst | src;
	$(Z_flag) = (tmp == 0);
	dst = tmp;
}

:OR saddr,"#"imm8 			is op1b_byte=0x6A; saddr; imm8
{
	inst_or(saddr, imm8);
}

:OR A,"#"imm8 				is op1b_byte=0x6C; imm8 & A
{
	inst_or(A, imm8);
}

:OR A,op2b_reg0 			is op1b_byte=0x61; op2b_hi=0x6 & op2b_b3=1 & op2b_reg0 & A
{
	inst_or(A,op2b_reg0);
}

:OR op2b_reg0,A 			is op1b_byte=0x61; op2b_hi=0x6 & op2b_b3=0 & op2b_reg0 & A
{
	inst_or(op2b_reg0,A);
}

:OR A,hl_offset 			is op1b_byte=0x6E; hl_offset & A
{
	inst_or(A, hl_offset);
}

:OR A,!addr16_1x 				is op1b_byte=0x6F; addr16_1x & A
{
	inst_or(A, addr16_1x);
}

:OR A,saddr 				is op1b_byte=0x6B; saddr & A
{
	inst_or(A, saddr);
}

#:XOR
#TODO: *
#DONE:	XOR A,r
#		XOR r,A
#		XOR A,#byte
#		xor a,saddr
macro inst_xor(dst, src){
	$(Z_flag) = (dst == src);
	dst = (dst ^ src);
}

:XOR A,op2b_reg0 			is op1b_byte=0x61; op2b_hi=0x7 & op2b_b3=1 & op2b_reg0 & A
{
	inst_xor(A,op2b_reg0);
}	

:XOR op2b_reg0,A 			is op1b_byte=0x61; op2b_hi=0x7 & op2b_b3=0 & op2b_reg0 & A
{
	inst_xor(op2b_reg0,A);
}

:XOR A,"#"imm8 				is op1b_byte=0x7C; imm8 & A
{
	inst_xor(A,imm8);
}

:XOR A,saddr 				is op1b_byte=0x7B; saddr & A
{
	inst_xor(A, saddr);
}
#:CMP
#TODO: Check if CMP operands are in wrong order in macro. ISA is unclear.
#TODO: Rest of CMP
# 		we've done 	cmp a, imm8
#				 	cmp a, reg
#					cmp reg, a
#					cmp !addr16, #byte
#					cmp a, saddr
#					cmp saddr, imm8
#					cmp A,[hl+byte]
#					cmp A, !addr16
#					cmp !add16, #byte
#					cmp A, [hl]
:CMP A,"#"imm8 	is op1b_byte=0x4C; imm8 & A {
	cmp8_set_flags(A, imm8);
}

:CMP A,op2b_reg0	is op1b_byte=0x61; op2b_hi=0x4 & op2b_b3=0x1 & 
						op2b_reg0 & op2b_reg0_dupe!=0x1 & A
{
	cmp8_set_flags(A, op2b_reg0);
}

:CMP op2b_reg0,A 	is op1b_byte=0x61; op2b_hi=0x4 & op2b_b3=0x0 &
						op2b_reg0 & op2b_reg0_dupe!=0x1 & A
{
	cmp8_set_flags(op2b_reg0, A);
}

:CMP !addr16,"#"imm8 	is op1b_byte=0x40; addr16; imm8{
	val:1 = 0x0;
	read_byte(val, addr16);
	cmp8_set_flags(val, imm8);
}

:CMP A, saddr 			is op1b_byte=0x4B; saddr & A
{
	cmp8_set_flags(A, saddr);
}

:CMP saddr,"#"imm8 		is op1b_byte=0x4A; saddr; imm8
{
	cmp8_set_flags(saddr, imm8);
}

:CMP A,hl_offset 		is op1b_byte=0x4E; hl_offset & A
{
	cmp8_set_flags(A, hl_offset);
}

:CMP A,!addr16_1x		is op1b_byte=0x4F; addr16_1x & A
{
	cmp8_set_flags(A, addr16_1x);
}

:CMP es_addr16_byte,"#"imm8 	is esmarker=0x11; op1b_byte=0x40; es_addr16_byte; imm8
{
	cmp8_set_flags(es_addr16_byte, imm8);
}

:CMP A,hl_ptr_byte 			is op1b_byte=0x4D & A & hl_ptr_byte
{
	cmp8_set_flags(A, hl_ptr_byte);
}


:CMP0 op1b_reg0 		is op1b_hi=0xD & op1b_b3=0 & op1b_reg0 & op1b_reg0_dupe<4 
{
	$(AC_flag) = 0;
	$(CY_flag) = 0;
	$(Z_flag)  = (op1b_reg0 == 0x0);
}

:CMP0 !addr16_1x 			is op1b_byte=0xD5; addr16_1x
{
	$(AC_flag) = 0;
	$(CY_flag) = 0;
	$(Z_flag)  = (addr16_1x == 0x0);
}

:CMP0 saddr 			is op1b_byte=0xD4; saddr
{
	$(AC_flag) = 0;
	$(CY_flag) = 0;
	$(Z_flag)  = (saddr == 0x0);
}

:CMP0 es_addr16_byte 	is op1b_byte=0x11; op2b_byte=0xD5; es_addr16_byte
{
	$(AC_flag) = 0;
	$(CY_flag) = 0;
	$(Z_flag)  = (es_addr16_byte == 0);
}


#:CMPS

#:ADDW
#TODO: instruction macro for addw
#TODO: etc
#DONE: addw ES instructions
:ADDW AX,"#"simm16 	is op1b_byte=0x04; simm16 & AX 
{
	addw_set_flags(AX, simm16);
	AX = AX + simm16;
}

:ADDW AX,!addr16_2x	is op1b_byte=0x02; addr16_2x & AX
{
	addw_set_flags(AX, addr16_2x);
	AX = AX + addr16_2x;
}

:ADDW SP,"#"imm8 	is op1b_byte=0x10; imm8 & SP 
{
	SP = SP + zext(imm8:1);
}

:ADDW AX,op1b_2xreg is op1b_hi=0x0 & op1b_2xreg & op1b_b0=1 & AX
{
	addw_set_flags(AX, op1b_2xreg);
	AX = AX + op1b_2xreg;
}

:ADDW AX,hl_offset_word is op1b_byte=0x61; op2b_byte=0x09; hl_offset_word & AX
{
	addw_set_flags(AX, hl_offset_word);
	AX = AX + hl_offset_word;
}

:ADDW AX,saddrp			is op1b_byte=0x06; saddrp & AX
{
	addw_set_flags(AX, saddrp);
	AX = AX + saddrp;
}

#:SUBW
#TODO: build instruction macro
#TODO: etc
#DONE: subw AX, #imm16
#		SUBW AX, rp
#		SUBW SP, #imm8
#		subw AX, !addr16
:SUBW AX,"#"imm16 	is op1b_byte=0x24; imm16 & AX
{
	subw_set_flags(AX,imm16);
	AX = AX - imm16;
}

:SUBW AX, op1b_reg_rp 	is op1b_hi=0x2 & op1b_b3=0 & op1b_reg_rp & op1b_b0=1 & op1b_reg_rp_dupe!=0 & AX
{
	subw_set_flags(AX,op1b_reg_rp);
	AX = AX - op1b_reg_rp;
}

:SUBW AX,saddrp 		is op1b_byte=0x26; saddrp & AX
{
	subw_set_flags(AX, saddrp);
	AX = AX - saddrp;
}

:SUBW SP,"#"imm8 		is op1b_byte=0x20; imm8 & SP
{
	local tmp:2 = sext(imm8:1);
	subw_set_flags(SP,tmp);
	SP = SP - tmp;
}

:SUBW AX,!addr16_2x 	is op1b_byte=0x22; addr16_2x & AX
{
	subw_set_flags(AX, addr16_2x);
	AX = AX - addr16_2x;
}

#:CMPW
#TODO: cmpw ES cases
:CMPW AX,"#"imm16 	is op1b_byte=0x44; imm16 & AX{
	cmpw_set_flags(AX, imm16);
}

:CMPW AX,op1b_2xreg is op1b_hi=0x4 & op1b_b3=0 & op1b_2xreg & op1b_b0=1 & AX
{
	cmpw_set_flags(AX, op1b_2xreg);
}

:CMPW AX,[HL+adr8] 	is op1b_byte=0x61; op2b_byte=0x49; adr8 & AX & HL
{
	local ptr:$(PTRSIZE) = 0x0;
	reg_stackarea_offset8(ptr, HL, adr8);
	local tmp = *:2 ptr;
	cmpw_set_flags(AX, tmp);
}

:CMPW AX,!addr16_2x is op1b_byte=0x42; addr16_2x & AX
{
	cmpw_set_flags(AX, addr16_2x);
}

:CMPW AX,saddrp 	is op1b_byte=0x46; saddrp & AX 
{
	cmpw_set_flags(AX, saddrp);
}


#TODO: figure out how to make this less nasty without confusing the compiler:
:MULU X (AX"="A"*X")			is op1b_byte=0xD6 & X & A & AX
{
	local Aext:2 = zext(A:1);
	local Xext:2 = zext(X:1);
	AX = Aext * Xext;
}

#:MULHU
#:MULH
#:DIVHU
#:DIVWU
#:MACHU
#:MACH

#:INC
#TODO: set CY and AC flags
#TODO: INC ES operations

macro inst_inc(dst){
	$(Z_flag) = (dst == 0xFF);
	dst = dst + 1;
}

:INC op1b_reg0 		is op1b_hi=0x8 & op1b_b3=0 & op1b_reg0 {
	inst_inc(op1b_reg0);
}

:INC hl_offset 		is op1b_byte=0x61; op2b_byte=0x59; hl_offset
{
	inst_inc(hl_offset);
}

:INC saddr 			is op1b_byte=0xA4; saddr
{
	inst_inc(saddr);
}

:INC !addr16_1x 	is op1b_byte=0xA0; addr16_1x
{
	inst_inc(addr16_1x);
}

#:DEC
#TODO: set CY and AC flags
#TODO: all of DEC except register mode
#						dec hl+byte
#						dec saddr
macro inst_dec(dst){
	$(Z_flag) = (dst == 0x1);
	dst = dst - 1;
}

:DEC op1b_reg0 		is op1b_hi=0x9 & op1b_b3=0 & op1b_reg0 {
	inst_dec(op1b_reg0);
}

:DEC hl_offset 		is op1b_byte=0x61; op2b_byte=0x69; hl_offset
{
	inst_dec(hl_offset);
}

:DEC saddr 			is op1b_byte=0xB4; saddr
{
	inst_dec(saddr);
}

#:INCW
#TODO: set CY and AC flags
#TODO: incw es:!addr16 / incw es:[HL+byte]
macro inst_incw(dst){
	$(Z_flag) = (dst == 0xFFFF);
	dst = dst + 1;
}

:INCW op1b_2xreg 	is op1b_hi=0xA & op1b_b3=0 & op1b_2xreg & op1b_b0=1
{
	inst_incw(op1b_2xreg);
}

:INCW hl_offset_word 	is op1b_byte=0x61; op2b_byte=0x79; hl_offset_word
{
	inst_incw(hl_offset_word);
}

:INCW saddrp 			is op1b_byte=0xA6; saddrp
{
	inst_incw(saddrp);
}

:INCW !addr16_2x 		is op1b_byte=0xA2; addr16_2x
{
	inst_incw(addr16_2x);
}

#:DECW
#TODO: set CY and AC flags
#TODO: decw ES: cases
macro inst_decw(dst){
	$(Z_flag) = (dst == 0x0001);
	dst = dst - 1;
}

:DECW op1b_2xreg 	is op1b_hi=0xB & op1b_b3=0 & op1b_2xreg & op1b_b0=1
{
	inst_decw(op1b_2xreg);
}

:DECW hl_offset 	is op1b_byte=0x61; op2b_byte=0x89; hl_offset
{
	inst_decw(hl_offset);
}

:DECW saddrp  		is op1b_byte=0xB6; saddrp
{
	inst_decw(saddrp);
}

:DECW !addr16_2x  	is op1b_byte=0xB2; addr16_2x
{
	inst_decw(addr16_2x);
}

#TODO: create right-shift macro
:SHR A, op2b_bit_sel is op1b_byte=0x31; op2b_b7=0 & op2b_bit_sel & op2b_lo=0xA & A
{
	local lobit:1 = 0;
	local shiftcount:1 = 0;
	local shifted:1 = A;
	<looptop>
	lobit = shifted[0,1];
	shiftcount = shiftcount + 1;
	shifted = shifted >> 1;
	if (shiftcount != op2b_bit_sel) goto <looptop>;
	$(CY_flag) = lobit&0x1;
	A = shifted;
}

:SHRW AX,op2b_hi_val	is op1b_byte=0x31; op2b_hi_val & op2b_lo=0xE & op2b_hi!=0x0 & AX {
	#TODO: just realized i screwed up how flags are set in shift ops, need to fix that.
	sr_set_flags16(AX, op2b_hi_val);
	AX = AX >> op2b_hi_val;
}

#:SHL

macro inst_shlw(reg, shiftamt){
	local hibt:1=0;
	local shiftcount:1 = 0;
	local shifted:2 = reg;
	<looptop>
	hibit = shifted[15,1];
	shiftcount = shiftcount+1;
	shifted = shifted<<1;
	if (shiftcount!=shiftamt) goto <looptop>;
	$(CY_flag)= hibit[0,1];
	reg = shifted;
}

:SHLW AX,op2b_hi_val 	is op1b_byte=0x31; op2b_hi_val & op2b_lo=0xD & op2b_hi!=0 & AX 
{
	inst_shlw(AX, op2b_hi_val);
}

:SHLW BC,op2b_hi_val 	is op1b_byte=0x31; op2b_hi_val & op2b_lo=0xC & op2b_hi!=0 & BC
{
	inst_shlw(BC, op2b_hi_val);
}

:SAR A,op2b_hi_val 	is op1b_byte=0x31; op2b_hi_val & op2b_lo=0xB & op2b_hi<0x8 & A {
	sr_set_flags8(A, op2b_hi_val);
	A = A s>> op2b_hi_val;
} 

macro inst_sarw(reg, shiftamt){
	local lobit:1=0;
	local shiftcount:1 = 0;
	local shifted:2 = reg;
	<looptop>
	lobit = shifted[15,1];
	shiftcount = shiftcount+1;
	shifted = shifted s>> 1;
	if (shiftcount!=shiftamt) goto <looptop>;
	$(CY_flag)= lobit[0,1];
	reg = shifted;
}

:SARW AX,op2b_hi_val 	is op1b_byte=0x31; op2b_hi_val & op2b_lo=0xF & op2b_hi!=0 & AX
{
	inst_sarw(AX, op2b_hi_val);
}

#:ROR
#:ROL

:RORC A,1 				is op1b_byte=0x61; op2b_byte=0xFB & A
{
	local tmp:1 = $(CY_flag);
	$(CY_flag) = A[0,1];
	A = A >> 1;
	A[7,1] = tmp;
}

:ROLC A,1 				is op1b_byte=0x61; op2b_byte=0xDC & A
{
	local tmp:1 = $(CY_flag);
	$(CY_flag) = A[7,1];
	A = A << 1;
	A[0,1] = tmp[0,1];
}

macro inst_rolwc(dst){
	local tmp:1 = $(CY_flag);
	$(CY_flag) = dst[15,1];
	dst = dst << 1;
	dst[0,1] = tmp[0,1];
}

:ROLWC AX,1				is op1b_byte=0x61; op2b_byte=0xEE & AX
{
	inst_rolwc(AX);
}

:ROLWC BC,1				is op1b_byte=0x61; op2b_byte=0xFE & BC
{
	inst_rolwc(BC);
}

#:MOV1
#TODO: clean up with macros, this is nasty
#TODO: 	all mov1 except mov1 CY, A.x
#						mov1 sfr.x, CY
#						mov1 CY, [HL].x
#						mov1 [HL].x, CY
#						MOV1 CY, saddr.x
#						MOV1 saddr.x, CY
#						MOV1 A.x, CY
:MOV1 op3b_sfr"."op2b_bit_sel,"CY" 	is op1b_byte=0x71; op2b_b7=0x0 & op2b_bit_sel & op2b_lo=0x9; op3b_hi=0xF & op3b_b3=1 & op3b_sfr
{
	local tmp = op3b_sfr;
	local mask = (0xFF & (~(0x1)<<op2b_bit_sel));
	tmp = tmp & mask;
	op3b_sfr = tmp|($(CY_flag)<<op2b_bit_sel);
}

:MOV1 "CY,"A"."op2b_bit_sel 	is op1b_byte=0x71; op2b_b7=1 & op2b_bit_sel & op2b_lo=0xC & A
{
	$(CY_flag) = ((A>>op2b_bit_sel)&0x1);
}

#TODO: Ghidra thinks the bit select value is the offset. needs to be fixed.
:MOV1 "CY,"[HL]"."op2b_bit_sel 	is op1b_byte=0x71; op2b_b7=1 & op2b_bit_sel & op2b_lo=0x4 & HL 
{
	local tmp:1 = 0x0;
	read_byte(tmp, HL);
	$(CY_flag) = ((tmp>>op2b_bit_sel)&0x1);
}

:MOV1 [HL]"."op2b_bit_sel,"CY" 	is op1b_byte=0x71; op2b_b7=1 & op2b_bit_sel & op2b_lo=0x1 & HL
{
	local hl_dupe:1 = 0x0;
	read_byte(hl_dupe, HL);
	local mask = ~(0x1 << op2b_bit_sel);
	hl_dupe = hl_dupe & mask;
	hl_dupe = hl_dupe|($(CY_flag)<<op2b_bit_sel);
	write_byte(hl_dupe, HL);
}

:MOV1 "CY,"saddr"."op2b_bit_sel 	is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x4; saddr
{
	local tmp:1 = 0x0;
	bit_get(saddr, op2b_bit_sel, tmp);
	$(CY_flag) = tmp[0,1];

}

:MOV1 saddr"."op2b_bit_sel",CY" 	is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x1; saddr 
{
	local tmp:1 = 0x0;
	bit_get(saddr, op2b_bit_sel, tmp);
	$(CY_flag) = tmp[0,1];
}

:MOV1 A"."op2b_bit_sel",CY" 		is op1b_byte=0x71; op2b_b7=1 & op2b_bit_sel & op2b_lo=0x9 & A
{
	local tmp:1 = $(CY_flag);
	bit_set_to(A, op2b_bit_sel, tmp);
}

#:AND1
#TODO: *
#DONE: 	CY, A.x
#		CY,	sfr.x 
macro inst_and1(src, bit_sel){
	local bit:1 = 0;
	bit_get(src, bit_sel, bit);
	bit = bit & $(CY_flag);
	$(CY_flag) = bit;
}

:AND1 "CY,"A"."op2b_bit_sel 		is op1b_byte=0x71; op2b_b7=1 & op2b_bit_sel & op2b_lo=0xD & A
{
	inst_and1(A, op2b_bit_sel);
}

:AND1 "CY,"op3b_sfr"."op2b_bit_sel 	is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0xD; op3b_hi=0xF & op3b_b3=1 & op3b_sfr
{
	inst_and1(op3b_sfr, op2b_bit_sel);
}

:AND1 "CY,"sfr_raw1"."op2b_bit_sel 	is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0xD; sfr_raw1 & uadr8<0xF8
{
	inst_and1(sfr_raw1, op2b_bit_sel);
}


#:OR1
#TODO: *
#done: or1 cy, a.x
macro inst_or1(src, bit_sel){
	local bit:1 = 0;
	bit_get(src, bit_sel, bit);
	bit = bit | $(CY_flag);
	$(CY_flag) = bit;
}

:OR1 "CY,"A"."op2b_bit_sel 			is op1b_byte=0x71; op2b_b7=1 & op2b_bit_sel & op2b_lo=0xE & A
{
	inst_or1(A, op2b_bit_sel);
}

#:XOR1
#TODO: *
#DONE:	XOR1 CY,saddr.x
#		XOR1 CY,A.x

macro inst_xor1(src, bit_sel){
	local bit:1 = 0;
	bit_get(src, bit_sel, bit);
	bit = bit ^ $(CY_flag);
	$(CY_flag) = bit;
}
:XOR1 "CY,"saddr"."op2b_bit_sel 	is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x7; saddr
{
	inst_xor1(saddr, op2b_bit_sel);
}

:XOR1 "CY,"A"."op2b_bit_sel 		is op1b_byte=0x71; op2b_b7=1 & op2b_bit_sel & op2b_lo=0xF & A
{
	inst_xor1(A, op2b_bit_sel);
}

#:SET1
#TODO: all set1 not in done list
#TODO: reuse bit_set_to macro in other spots
#Done: 				set1 !addr16.x
#					set1, sfr
#					set1 saddr
#					set1 CY

:SET1 !addr16_1x"."op2b_bit_sel 	is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0; addr16_1x
{
	local tmp:1 = addr16_1x;
	bit_set_to(tmp, op2b_bit_sel, 1);
	addr16_1x = tmp;
}

:SET1 op3b_sfr"."op2b_bit_sel 		is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0xA; op3b_hi=0xF & op3b_b3=1 & op3b_sfr
{
	local tmp:1 = op3b_sfr;
	bit_set_to(tmp, op2b_bit_sel, 1);
	op3b_sfr = tmp;
}

:SET1 sfr_raw1"."op2b_bit_sel 		is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0xA; sfr_raw1 & uadr8<0xF8 
{
	local tmp:1 = sfr_raw1;
	bit_set_to(tmp, op2b_bit_sel, 1);
	sfr_raw1 = tmp;
}

:SET1 saddr"."op2b_bit_sel 			is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x2; saddr
{
	local tmp:1 = saddr;
	bit_set_to(tmp, op2b_bit_sel, 1);
	saddr = tmp;
}

:SET1 "CY"							is op1b_byte=0x71; op2b_byte=0x80
{
	$(CY_flag) = 0x1;
}

#:CLR1
#TODO: etc
#DONE: CLR1 addr16
#		CLR1 psw
#		CLR1 sfr
#		CLR! saddr
:CLR1 !addr16_1x"."op2b_bit_sel 	is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=8; addr16_1x
{
	local tmp:1 = addr16_1x;
	bit_set_to(tmp, op2b_bit_sel, 0);
	addr16_1x = tmp;
}

:CLR1 op3b_sfr"."op2b_bit_sel 			is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0xB; op3b_hi=0xF & op3b_b3=1 & op3b_sfr
{
	bit_set_to(op3b_sfr, op2b_bit_sel, 0);
}

:CLR1 sfr_raw1"."op2b_bit_sel 		is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0xB; sfr_raw1 & uadr8<0xF0
{
	bit_set_to(sfr_raw1, op2b_bit_sel, 0);
}

:CLR1 sfr_raw1"."op2b_bit_sel 		is op1b_byte=0x71; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x3; sfr_raw1
{
	local tmp:1 = sfr_raw1;
	bit_set_to(tmp, op2b_bit_sel, 0);
	sfr_raw1 = tmp;
}


#TODO: not1, set1, and clr1 disasm gross because of lack of bitslice registers.
:NOT1 "CY"							is op1b_byte=0x71; op2b_byte=0xC0
{
	$(CY_flag) = !$(CY_flag);
}


macro inst_call(targ_func){
	local retpc:3 = inst_next;
	pushpc(retpc, 0x00:1);
	PC = &targ_func;
	call targ_func;
}

:CALL !jaddr16 		is op1b_byte=0xFD; jaddr16 
{
	inst_call(jaddr16);
}

:CALL !!jaddr20 	is op1b_byte=0xFC; jaddr20
{
	inst_call(jaddr20);
}

:CALL op2b_reg_rp 	is op1b_byte=0x61; op2b_b7=1 & op2b_b6=1 & op2b_reg_rp & op2b_lo=0xA
{
	inst_call(op2b_reg_rp);
}

:CALL $!jdisp16 	is op1b_byte=0xFE; jdisp16
{
	inst_call(jdisp16);
}



#TODO: change how callt_addr is fetched, its messing with xrefs
:CALLT callt_addr 	is op1b_byte=0x61; callt_addr
{
	inst_call(callt_addr);
}



#TODO: make a virtual operand for brk instead of setting up the call in 
#brk?
:BRK 				is op1b_byte=0x61; op2b_byte=0xcc
{
	local retpc:$(PTRSIZE) = inst_next;
	pushpc(retpc,PSW);
	$(IE_flag) = 0;
	local vector:$(PTRSIZE) = 0x7E;
	local jmptarget:$(PTRSIZE) = 0;
	jmptarget[0,16] = *:2 vector;
	PC = jmptarget;
	call [PC];
}

:RET 				is op1b_byte=0xD7 
{
	local tmp:1 = 0;
	poppc(PC, tmp);
	return [PC];
}

:RETI 				is op1b_byte=0x61; op2b_byte=0xFC
{
	poppc(PC, PSW);
	return [PC];
}

#:RETB


:PUSH op1b_2xreg 	is op1b_hi=0xC & op1b_b3=0 & op1b_2xreg & op1b_b0=1 {
	push(op1b_2xreg);
}

:PUSH PSW 			is op1b_byte=0x61; op2b_byte=0xDD & PSW
{
	push(PSW);
}


:POP op1b_2xreg 	is op1b_hi=0xC & op1b_b3=0 & op1b_2xreg & op1b_b0=0 {
	pop(op1b_2xreg);
}

:POP PSW 			is op1b_byte=0x61; op2b_byte=0xCD & PSW
{
	pop(PSW);
}

#:BR
#TODO: need to modify PC here too?
:BR "$"RelAddr8 		is op1b_byte=0xEF; RelAddr8 {
	goto RelAddr8;
}

:BR !jaddr16			is op1b_byte=0xED; jaddr16
{
	goto jaddr16;
}

:BR $!jdisp16 			is op1b_byte=0xEE; jdisp16
{
	goto jdisp16;
}

:BR !!jaddr20 			is op1b_byte=0xEC; jaddr20
{
	goto jaddr20;
}

:BR AX 					is op1b_byte=0x61; op2b_byte=0xCB & AX 
{
	local jmptarget:$(PTRSIZE) = zext(AX:2);
	goto [jmptarget];
}



:BC "$"RelAddr8			is op1b_byte=0xDC; RelAddr8 {
	if ($(CY_flag)) goto RelAddr8;
}

:BNC "$"RelAddr8 		is op1b_byte=0xDE; RelAddr8 {
	if (!$(CY_flag)) goto RelAddr8;
}

:BZ "$"RelAddr8 		is op1b_byte=0xDD; RelAddr8 {
	if ($(Z_flag)) goto RelAddr8;
}

:BNZ "$"RelAddr8 		is op1b_byte=0xDF; RelAddr8 {
	if (!$(Z_flag)) goto RelAddr8;
}

:BH "$"RelAddr8 		is op1b_byte=0x61; op2b_byte=0xC3; RelAddr8 {
	if (!($(Z_flag)|$(CY_flag))) goto RelAddr8;
}

:BNH "$"RelAddr8 		is op1b_byte=0x61; op2b_byte=0xD3; RelAddr8 {
	if (($(Z_flag)|$(CY_flag))) goto RelAddr8;
}

#:BT
#TODO: all
#DONE: BT A.x, adr8
#	   BT saddr.x, $addr20
#	   BT sfr.x, $addr20
macro inst_bt(src, bit_sel, jmpaddr){
	local bit = 0x0;
	bit_get(src, bit_sel, bit);
	if bit goto jmpaddr;
}

:BT A"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x3; RelAddr8 & A
{
	inst_bt(A, op2b_bit_sel, RelAddr8);
}

:BT saddr"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x2; saddr; RelAddr8
{
	inst_bt(saddr, op2b_bit_sel, RelAddr8);
}

:BT sfr_raw1"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=1 & op2b_bit_sel & op2b_lo=0x2; sfr_raw1 & uadr8<0xF8; RelAddr8
{
	inst_bt(sfr_raw1, op2b_bit_sel, RelAddr8);
}

:BT op3b_sfr"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=1 & op2b_bit_sel & op2b_lo=0x2; op3b_hi=0xF & op3b_b3=1 & op3b_sfr; RelAddr8
{
	inst_bt(op3b_sfr, op2b_bit_sel, RelAddr8);
}

#:BF
#TODO: all
#DONE: BF A.x, adr8
# 		BF saddr.x, $addr20
#		BF sfr.x, $addr20
macro inst_bf(src, bit_sel, jmpaddr){
	local bit = 0x0;
	bit_get(src, bit_sel, bit);
	if !bit goto jmpaddr;
}

:BF A"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x5; RelAddr8 & A
{
	inst_bf(A, op2b_bit_sel, RelAddr8);
}

:BF saddr"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=0 & op2b_bit_sel & op2b_lo=0x4; saddr; RelAddr8
{
	inst_bf(saddr, op2b_bit_sel, RelAddr8);
}

:BF op3b_sfr"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=1 & op2b_bit_sel & op2b_lo=0x4; op3b_hi=0xF & op3b_b3=1 & op3b_sfr; RelAddr8
{
	inst_bf(op3b_sfr, op2b_bit_sel, RelAddr8);
}

:BF sfr_raw1"."op2b_bit_sel,RelAddr8 is op1b_byte=0x31; op2b_b7=1 & op2b_bit_sel & op2b_lo=0x4; sfr_raw1 & uadr8<0xF8; RelAddr8
{
	inst_bf(sfr_raw1, op2b_bit_sel, RelAddr8);
}



#:BTCLR

:SKC 					is op1b_byte=0x61; op2b_byte=0xC8
{
	if $(CY_flag) goto inst_next;
	delayslot(1);
	goto inst_next;
}

:SKNC					is op1b_byte=0x61; op2b_byte=0xD8
{
	if !$(CY_flag) goto inst_next;
	delayslot(1);
	goto inst_next;
}

:SKZ 					is op1b_byte=0x61; op2b_byte=0xE8 
{
	if  $(Z_flag) goto inst_next;
	delayslot(1);
	goto inst_next;
}

:SKNZ 					is op1b_byte=0x61; op2b_byte=0xF8 
{
	if !$(Z_flag) goto inst_next;
	delayslot(1);
	goto inst_next;
}

:SKH 					is op1b_byte=0x61; op2b_byte=0xE3
{
	local z_or_cy:1 = $(Z_flag) | $(CY_flag);
	if z_or_cy goto inst_next;
	delayslot(1);
	goto inst_next;
}

:SKNH					is op1b_byte=0x61; op2b_byte=0xF3
{
	local z_or_cy:1 = $(Z_flag) | $(CY_flag);
	if !z_or_cy goto inst_next;
	delayslot(1);
	goto inst_next;
}

:SEL "RB"op2b_reg_rbsel			is op1b_byte=0x61; op2b_hi2=0x3 & op2b_reg_rbsel & op2b_lo=0xF 
{
	$(RBS1_flag) = ((op2b_reg_rbsel>>1)&0x1);
	$(RBS0_flag) = op2b_reg_rbsel&0x1;
}

:NOP					is op1b_byte=0x00 {}

#:EI
#:DI

:HALT 					is op1b_byte=0x61; op2b_byte=0xED
{
	halt();
}

:STOP 					is op1b_byte=0x61; op2b_byte=0xFD
{
	stop();
}

:INVALID 				is op1b_byte=0xFF 
{
	invalid();
}